Домашнее Задание по Алгоритмам и структурам данных

Штойк Валерия, УИБО-14-24
__________________________________________________________

### Бинарная куча
- **C++**:В C++ для работы с бинарной кучей используется стандартная библиотека STL. Она предоставляет готовые функции std::make_heap, std::push_heap и std::pop_heap, которые работают с массивом через итераторы. Эти функции позволяют быстро построить кучу из набора элементов, добавить новый элемент и удалить наименьший или наибольший. Внутри операции выполняются с перестановкой элементов массива, что поддерживает правильное свойство кучи.  
- **Java**: структура `PriorityQueue<E>` реализует бинарную кучу на массиве. Методы `add(E e)`, `poll()`, `peek()` напрямую управляют добавлением, удалением и доступом к минимальному элементу. Операции вставки и восстановления порядка выполняются за счёт внутреннего массива и `siftUp/siftDown` операций.  
- **Python**: модуль `heapq` реализует бинарную кучу через список. Функции `heapq.heapify(list)`, `heapq.heappush(heap, item)`, `heapq.heappop(heap)` напрямую обеспечивают операции с кучей. Внутренне используется *min-heap*, где наименьший элемент всегда на позиции `0`.

***

### Биномиальная куча
- **C++**: биномиальная куча пишется вручную через структуры `struct BinomialNode` и указатели. Основные операции реализуются функциями `binomialLink(nodeA, nodeB)`, `binomialHeapMerge(h1, h2)`, `binomialHeapInsert(heap, key)`. Логика основана на рекурсивном объединении деревьев одного порядка.  
- **Java**: реализуется на основе собственных классов `BinomialNode` с атрибутами ключа, степени и связей на детей/родителей. Методы вроде `insert()`, `merge()`, `extractMin()` определяются вручную, опираясь на списки узлов. Библиотека стандартного уровня не предоставляет готовой реализации.  
- **Python**: как и в Java, требуется ручная реализация с классами `BinomialNode` и `BinomialHeap`. Операции `insert(key)`, `union(otherHeap)`, `extract_min()` описываются через обработку списков деревьев и указателей на детей. Работа идёт с динамическими структурами, стандартных функций в библиотеке нет.

***

### Куча Фибоначчи
- **C++**: нет стандартной поддержки, создаются структуры `FibNode` с указателями на левый/правый в двусвязном списке. Методы `insert()`, `union()`, `decreaseKey()`, `extractMin()` реализуются с использованием вспомогательных функций для каскадных слияний и корневого списка.  
- **Java**: построение идёт через классы `FibonacciHeap` и `FibonacciNode`, с управлением связями через двунаправленные списки объектов. При уменьшении ключа применяется каскадное "cut"-поведение, метод `decreaseKey(node, newKey)` использует метки для корректировок структуры.  
- **Python**: создаётся класс `FibNode` для узла (ключ, степень, ссылки, метка) и `FibonacciHeap`, где методы `insert`, `meld`, `extract_min`, `decrease_key` работают через динамические списки и обновления родительских связей. Стандартная библиотека Python таких структур не содержит.

***

### Хеш-таблицы
- **C++**: контейнер `std::unordered_map<Key, Value>` предлагает доступ через оператор `[]`, который вставляет новый элемент при необходимости. Для поиска и удаления используются методы `.find(key)` и `.erase(key)`. Коллизии и перераспределение бакетов скрыты в реализации.  
- **Java**: класс `HashMap<K,V>` работает методами `put(key, value)`, `get(key)`, `remove(key)`. При вставке происходит автоматическое вычисление хеша через `hashCode()` и выбор корзины. Система сама выполняет рехеширование при достижении порога нагрузки.  
- **Python**: встроенный тип данных `dict` реализует хеш-таблицу. Синтаксис `[ ]` обеспечивает вставку и доступ: `d[key] = value`, `value = d[key]`. Методы `get(key)`, `pop(key)` также применяются. Реализация скрывает обработку коллизий и перестройку массива.
