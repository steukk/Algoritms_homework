Домашнее Задание по Алгоритмам и структурам данных

Штойк Валерия, УИБО-14-24
__________________________________________________________

### Бинарная куча

- В C++ для работы с бинарной кучей используют стандартные функции `<algorithm>`: `make_heap`, `push_heap`, `pop_heap`. Они применяют итераторы к массивообразным контейнерам (как `vector`), что позволяет эффективно представлять дерево в виде массива. Функции используют операции сравнения элементов, перестановки (например, `std::swap`) и арифметику индексов для навигации по дереву (родитель, дети).

- В Java применяется коллекция `PriorityQueue`, где ключевые методы — `add()` для вставки, `poll()` для удаления минимума, `peek()` для получения минимального элемента без удаления. Реализация скрыта, но в основе лежит двоичная куча. Методы выполняют сдвиги элементов по внутреннему массиву с помощью циклов и сравнений.

- В Python модуль `heapq` использует список как массив-кучу и функции `heappush()`, `heappop()` для вставки и удаления минимального элемента. В основе операции — перестановки и сравнения для поддержания свойства кучи. Для навигации вычисляются индексы родителей и детей через арифметические формулы.

***

### Биномиальная куча

- В C++ биномиальная куча реализуется через структуру узла с указателями на детей, родителей и соседей. Слияние деревьев и списков происходит с помощью рекурсивных функций, где активно используются указатели и операции присваивания. Свойство порядка поддерживается через циклы и условные операторы.

- В Java структура реализована классами с полями для связей между узлами (`parent`, `child`, `sibling`) и методами для слияния и вставки. Методы манипулируют ссылками и сравнивают ключи, используя условные операторы. Важна работа с рекурсией и обходом списков.

- В Python код опирается на простые классы с атрибутами для связей древовидной структуры и функции для слияния куч с рекурсией. Полезны операции сравнения ключей и присваивания, рекурсивные вызовы и манипуляции ссылками в виде атрибутов объектов.

***

### Куча Фибоначчи

- В C++ структура узла содержит указатели на左右 соседей (двусвязный список), детей и родителей, флаги для пометки. Основная операция вставки — добавление узла в кольцевой двусвязный список корней, при этом проверяется и обновляется минимальный элемент. Используются указатели, операции присваивания, сравнения и работа с круговыми списками.

- В Java узлы содержат ссылки на соседей, детей и родителей, а методы реализуют вставку и обновление минимума. Здесь активно используются операции работы с ссылками, циклы и проверки условий. Важна аккуратная работа с левой и правой ссылками для кольцевой структуры.

- В Python узлы — объекты с атрибутами-ссылками на соседей и детей, вставка в циклический двусвязный список реализована через переназначение атрибутов `left` и `right`. Методы используют операции сравнения, присваивания и манипуляции ссылками.

***

### Хеш-таблицы

- В C++ применяют `std::unordered_map`, который предоставляет методы `operator[]` для вставки и доступа к элементам, `insert()` и `find()` для поиска. Реализация скрыта, но ключевые операции — вычисление хеш-кода, сравнение ключей, управление коллизиями, что реализовано в стандартной библиотеке.

- Java использует `HashMap` с методами `put()`, `get()`, `containsKey()`. Эти методы оперируют хешированием ключей (через `hashCode()`), сравнением (`equals()`), вставкой и поиском, используя массивы и связанные списки или деревья для коллизий.

- В Python словари (`dict`) реализованы как хеш-таблицы с методами доступа `dict[key]` и модификации `dict[key] = value`. В основе — хеширование ключей (`__hash__()`) и сравнение на равенство (`__eq__()`), а также внутренняя организация массивов с разрешением коллизий.

***

Таким образом, ключевые операторы и функции для куч — это операции сравнения, присваивания, циклы для обхода и поддержки структуры дерева или списка, рекурсивные вызовы для операций слияния (биномиальная куча). Для хеш-таблиц — вычисление хешей, сравнение ключей, доступ через операторы индексирования или методы и управление коллизиями через списки или деревья. Все три языка предоставляют удобные классы и функции для многих операций этих структур, что упрощает их использование без необходимости ручной реализации большинства алгоритмов.

